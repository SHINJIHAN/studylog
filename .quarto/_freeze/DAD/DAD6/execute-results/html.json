{
  "hash": "17beff74904e21b26a68d5b06b355ac1",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"제 6장-두 모집단에 대한 비교\"\nformat: html\n---\n\n> Reporting Date: Setember. 18, 2024\n두 모집단의 모평균, 모비율, 모분산의 차이에 대한 가설검증 문제를 다루고자 한다.\n(12장: 두 모집단의 비교와 이어지는 내용이다.)\n\n표본 평균을 추정하려면, 표본의 크기와 모분산을 고려해야 한다.\n\n[  1  ]\n두 모분산 σ12,  σ 22 이 모두 알려져 있는 경우, \n\n\n두 모평균 차에 대한 \"추정량\"   ⇨   \"두  표본평균의  차\"\n통계적 추론을 위한 \"준비물\"    ⇨   \"추정량의  분포\"\n\n이 분포는 다음과 같은 평균과 분산을 가진 정규분포를 따른다:\n\n표준화된 확률변수 Z는 표준정규분포 N(0, 1)를 따른다.\n\n[  2  ]\n두 모분산 σ12,  σ 22 을 모두 모르는 경우,\n표본의 크기를 고려하게 된다.\n\n\n표본의 크기가 충분히 큰 경우 ( 25 이상 )\n\n중심극한정리에 의해 모집단의 분포에 관계없이 \nx̄ 와  ȳ 가 근사적으로 정규분포를 따른다.\n\n\n두 모분산의 추정치인 표본분산 s₁², s₂² 를 고려한 통계량을 사용하여 검정을 수행한다.\n\n[  3  ]\n두 모집단이 알려져 있지는 않지만,  모분산이 동일한 것으로 가정할 수 있는 경우,\n\n다음과 같은 평균과 분산을 가지는 정규분포를 따른다:\n\n\n[1] 과 동일하다.\n\n공통분산  σ ² 의  합동추정량 (Pooled Variance)\n\n자유도 n ₁ + n ₂ – 2인 t-분포를 따른다.\n\n[  4  ]\n두 모분산이 서로 다른 경우,  [3]번 식은 t-분포를 따르지 않는다.\n\n단, 아래와 같이 자유도를 수정할 경우,  근사적으로 t-분포를 따르게 된다.\n\n근사적으로 t-분포를 따르게 된다.\n\n수정된 자유도(df).\n\n\n독립표본에 의한 두 모평균의 비교:\n\n독 립 표 본    t – 검 정\n\n\n두 개의 서로 독립적인 집단의 평균을 비교하여\n그 차이가 통계적으로 유의한지 판단하는 방법이다.\n\n사례\n새로운 강의방식이 초등학생 독해력 향상에 도움이 되는가?\n\n::: {#b22e8972 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\n\nurl = \"https://raw.githubusercontent.com/SHINJIHAN/advanced-bigdata/main/data/Reading.csv\"\nReading = pd.read_csv(url)\nReading.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ID</th>\n      <th>Group</th>\n      <th>Score</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>New</td>\n      <td>75</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>New</td>\n      <td>80</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>New</td>\n      <td>72</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4</td>\n      <td>New</td>\n      <td>77</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5</td>\n      <td>New</td>\n      <td>69</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n가설검증을 결정하기 전에 데이터를 시각화한다.\n\n::: {#cb83af15 .cell execution_count=2}\n``` {.python .cell-code}\nimport seaborn as sns  # 박스 플롯\nsns.boxplot(x = 'Group', y = 'Score', data = Reading)\n```\n\n::: {.cell-output .cell-output-display}\n![](DAD6_files/figure-html/cell-3-output-1.png){width=597 height=429}\n:::\n:::\n\n\n중위수와 같은 요인을 비교한 결과, 차이가 나타나므로 이를 근거로 검증을 진행할 수 있다.\n\n::: {#a52e5d85 .cell execution_count=3}\n``` {.python .cell-code}\n# 바이올린 플롯\nsns.violinplot(x = 'Group', y = 'Score', data = Reading)\n```\n\n::: {.cell-output .cell-output-display}\n![](DAD6_files/figure-html/cell-4-output-1.png){width=585 height=429}\n:::\n:::\n\n\n::: {#142ad8c9 .cell execution_count=4}\n``` {.python .cell-code}\n# 기술통계량\nReading.groupby('Group').Score.describe()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>count</th>\n      <th>mean</th>\n      <th>std</th>\n      <th>min</th>\n      <th>25%</th>\n      <th>50%</th>\n      <th>75%</th>\n      <th>max</th>\n    </tr>\n    <tr>\n      <th>Group</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>New</th>\n      <td>8.0</td>\n      <td>75.375</td>\n      <td>4.373214</td>\n      <td>69.0</td>\n      <td>71.75</td>\n      <td>76.0</td>\n      <td>78.50</td>\n      <td>81.0</td>\n    </tr>\n    <tr>\n      <th>Old</th>\n      <td>8.0</td>\n      <td>69.125</td>\n      <td>4.086126</td>\n      <td>63.0</td>\n      <td>67.25</td>\n      <td>69.0</td>\n      <td>71.25</td>\n      <td>76.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n양측검정 적용.\n\n::: {#4769b694 .cell execution_count=5}\n``` {.python .cell-code}\n# 그룹 나누기\nNew = Reading[Reading.Group == 'New']\nOld = Reading[Reading.Group == 'Old']\n\n# 양측검증:\n# 두 강의 방식에 차이가 있다. vs 차이가 없다.\n\nfrom scipy.stats import ttest_ind  # 독립 t-검정\nttest_ind(New.Score, Old.Score, equal_var = True)\n\n\n# T통계량: 그룹 간 평균 차이가 실제로 존재하는지를 나타내는 통계량.\n# 통계량이 클수록 차이가 있을 가능성이 높다.\n\n# [3]번 통계량: statistic=2.9536127902039953\n\n\n# 두 꼬리 검정에서의 p-값: pvalue=0.010470744188033123\n\n# 통상적으로 p-값이 0.05보다 작으면 귀무가설을 기각할 수 있다. \n# 즉, 두 강의 방식에 차이가 있다고 결론 내릴 수 있다.\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nTtestResult(statistic=np.float64(2.9536127902039953), pvalue=np.float64(0.010470744188033123), df=np.float64(14.0))\n```\n:::\n:::\n\n\n양측검증을 수행한 뒤, p-value를 2로 나누어\n단측 검정을 수행한 것과 동일한 결과를 얻고 있다.\n\n::: {#a8ed325f .cell execution_count=6}\n``` {.python .cell-code}\n# 단측검정:\n# 새로운 학습법이 더 효과적이다. vs 효과적이지 않다.\n\nstat, pval = ttest_ind(New.Score, Old.Score, equal_var = True)\nprint(\"P\", pval/2)\n\n# p-값이 0.0052로 유의수준 0.05보다 작으므로, 대립가설을 채택할 수 있다.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nP 0.005235372094016561\n```\n:::\n:::\n\n\n단측검정과 등분산 가정 적용.\n\n::: {#de3300ec .cell execution_count=7}\n``` {.python .cell-code}\n# 단측검정\nfrom statsmodels.stats.weightstats import ttest_ind\nttest_ind(New.Score, Old.Score, alternative = 'larger', \n          usevar = 'pooled') # 등분산 가정 적용:\n          # 두 그룹 간의 분산이 동일하다고 가정\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n(np.float64(2.9536127902039953),\n np.float64(0.005235372094016561),\n np.float64(14.0))\n```\n:::\n:::\n\n\n단측검정과 이분산 가정 적용.\n\n::: {#97b2986c .cell execution_count=8}\n``` {.python .cell-code}\n# 단측검정\nttest_ind(New.Score, Old.Score, alternative = 'larger', \n          usevar = 'unequal') # 이분산 가정 적용:\n          # 두 그룹의 분산이 서로 다르다는 가정\n\n# [4]번 통계량: usevar= 'pooled' ⇨ 'unequal'\n# 14 ⇨ 13.935945095796395 (자유도가 실수로 바뀜)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n(np.float64(2.9536127902039953),\n np.float64(0.005256688626975243),\n np.float64(13.935945095796395))\n```\n:::\n:::\n\n\n결론적으로, 새로운 강의방식이 초등학생 독해력 향상에 도움이 된다고 할 수 있다.\n\n대응표본에 의한 두 모평균의 비교:\n\n대응표본  t – 검정\n\n어떤 신발의 마모율을 비교할 때, 독립 표본 검정에 경우,\n한 그룹의 사람이 왼쪽 신발을 신고, 다른 그룹의 사람이\n오른쪽 신발을 신더라도 상관이 없다.\n\n하지만 대응 표본 검정은 동일한 사람이 왼쪽 신발과\n오른쪽 신발을 모두 신어야 만 한다.\n\n각 쌍이 서로 연관되어 있으므로 두 신발을 신는 사람이\n동일해야 하며, 표본의 수도 일치해야 한다.\n\n이는 마모율에 영향을 줄 수 있는\n교락 요인(confounding factor),\n즉 신발을 신는 사람의 특성 등을 배제하기 때문이다.\n\n그러므로, 대응 표본 검정은 같은 대상에 대한\n실험 전후의 결과를 비교할 때 주로 사용된다.\n\n사례\n컴퓨터 교육을 실시하기 전과 후의 성적에 차이가 있는가?\n\n::: {#2c9cef92 .cell execution_count=9}\n``` {.python .cell-code}\nimport pandas as pd\n\nurl = \"https://raw.githubusercontent.com/SHINJIHAN/advanced-bigdata/main/data/Paired.csv\"\nPaired = pd.read_csv(url)\nPaired.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ID</th>\n      <th>Pretest</th>\n      <th>Posttest</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>80</td>\n      <td>82</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>73</td>\n      <td>71</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>70</td>\n      <td>95</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4</td>\n      <td>60</td>\n      <td>69</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5</td>\n      <td>88</td>\n      <td>100</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n박스플롯 시각화 및 기술 통계량 출력.\n\n::: {#e7e0624a .cell execution_count=10}\n``` {.python .cell-code}\nimport pandas as pd\nimport seaborn as sns\n\n# Pretest와 Posttest에 대한 박스플롯 시각화\nsns.boxplot(data = Paired.iloc[:, [1, 2]], \n            orient = 'h') # 수평 방향\n\n# Pretest와 Posttest의 차이 계산 및 새로운 열(Diff) 추가\nPaired[\"Diff\"] = Paired.Pretest - Paired.Posttest \n\t\t\t\t# = 교육 전 성적 - 교육 후 성적\n                # 교육이 효과가 있다면 교육 후 성적이 더 높을 것이므로\n                # 결과적으로는 변수 Diff의 값이 음수로 나와야 한다.\n```\n\n::: {.cell-output .cell-output-display}\n![](DAD6_files/figure-html/cell-11-output-1.png){width=603 height=411}\n:::\n:::\n\n\n두 변수에 대한 상자 그림\n\n::: {#bae0aedb .cell execution_count=11}\n``` {.python .cell-code}\nPaired.iloc[:,1:4].describe()\n\n# 변수 Diff 평균(mean)이 -7.93이며\n# 실제로 그래프 상에서도 대부분의 개체에서 \n# 변수 Diff의 값이 0보다 작음을 볼 수 있다.\n\n\n# 표준편차(std)는 데이터의 산포도(변동성)를 측정하는 지표로, \n# 데이터가 평균으로부터 얼마나 떨어져 있는지를 나타낸다. \n\n# 표준편차는 항상 0 이상의 값을 가지며, 음수가 될 수 없다. \n# 이는 표준편차가 데이터 값의 차이를 제곱하여 계산하기 때문이다.\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Pretest</th>\n      <th>Posttest</th>\n      <th>Diff</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>count</th>\n      <td>15.000000</td>\n      <td>15.000000</td>\n      <td>15.000000</td>\n    </tr>\n    <tr>\n      <th>mean</th>\n      <td>70.266667</td>\n      <td>78.200000</td>\n      <td>-7.933333</td>\n    </tr>\n    <tr>\n      <th>std</th>\n      <td>18.041487</td>\n      <td>14.313829</td>\n      <td>9.931671</td>\n    </tr>\n    <tr>\n      <th>min</th>\n      <td>37.000000</td>\n      <td>60.000000</td>\n      <td>-25.000000</td>\n    </tr>\n    <tr>\n      <th>25%</th>\n      <td>59.500000</td>\n      <td>67.000000</td>\n      <td>-12.500000</td>\n    </tr>\n    <tr>\n      <th>50%</th>\n      <td>73.000000</td>\n      <td>75.000000</td>\n      <td>-7.000000</td>\n    </tr>\n    <tr>\n      <th>75%</th>\n      <td>82.000000</td>\n      <td>90.500000</td>\n      <td>-2.500000</td>\n    </tr>\n    <tr>\n      <th>max</th>\n      <td>98.000000</td>\n      <td>100.000000</td>\n      <td>13.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n히스토그램 및 커널 밀도 추정(KDE) 시각화\n\n::: {#90eec772 .cell execution_count=12}\n``` {.python .cell-code}\nsns.distplot(Paired.Diff)\n\n# Seaborn의 최신 버전에서는 더 이상 지원되지 않으므로,\n# sns.histplot 또는 sns.kdeplot을 사용하는 것이 권장된다.\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\sinji\\AppData\\Local\\Temp\\ipykernel_10492\\4004193321.py:1: UserWarning: \n\n`distplot` is a deprecated function and will be removed in seaborn v0.14.0.\n\nPlease adapt your code to use either `displot` (a figure-level function with\nsimilar flexibility) or `histplot` (an axes-level function for histograms).\n\nFor a guide to updating your code to use the new functions, please see\nhttps://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751\n\n  sns.distplot(Paired.Diff)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](DAD6_files/figure-html/cell-13-output-2.png){width=597 height=429}\n:::\n:::\n\n\n::: {#693329e0 .cell execution_count=13}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# 히스토그램 그리기\nsns.histplot(Paired.Diff, \n             stat = 'density')  # y축을 밀도로 변경\n\n# KDE만 수정하기 위해 따로 그리기\nsns.kdeplot(Paired.Diff, \n\t\t\tfill = True) # 음영 처리\n\nplt.xlim(-40, 30)     # x축 범위 설정\n```\n\n::: {.cell-output .cell-output-display}\n![](DAD6_files/figure-html/cell-14-output-1.png){width=606 height=429}\n:::\n:::\n\n\n양측검정 적용\n\n::: {#e7db29ae .cell execution_count=14}\n``` {.python .cell-code}\n# ttest_rel에서 rel은 paired 또는 related를 의미한다.\n\n# 이 함수는 대응표본 t-검정을 수행하는 것으로, \n# 두 관련된 표본에 대한 평균의 차이를 비교하는 데 사용된다.\n\n\nfrom scipy.stats import ttest_rel\nttest_rel(Paired.Pretest, Paired.Posttest)\n\n# p-값이 0.0079(0.79%)로 0.05(5%)보다 작기 때문에 \n# 귀무가설을 기각하고 대립가설을 채택할 수 있다. \n# 이는 두 표본 간에 유의미한 차이가 있음을 의미한다.\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nTtestResult(statistic=np.float64(-3.093705670004429), pvalue=np.float64(0.007930923229026533), df=np.int64(14))\n```\n:::\n:::\n\n\n양측검증을 수행한 뒤, p-value를 2로 나누어\n단측 검정을 수행한 것과 동일한 결과를 얻고 있다.\n\n::: {#459616ec .cell execution_count=15}\n``` {.python .cell-code}\nstat, pval = ttest_rel(Paired.Pretest, Paired.Posttest)\nprint(\"one-sided p-value =\", pval/2)\n\n# 이 경우에도, p-값이 0.05보다 작으므로 \n# 귀무가설을 기각하고 대립가설을 채택할 수 있다.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\none-sided p-value = 0.003965461614513267\n```\n:::\n:::\n\n\n결론적으로 컴퓨터 교육을 실시하기 전과 후의 성적에 차이가 있으며, 사후 테스트의 결과가 더 좋다고 할 수 있다.\n\n독립표본에 의한 두 모비율의 비교:\n\n피셔의 정확검정\nFisher's Exact Test\n\n두 모비율에 대한 검정을 수행하기 위해 사용할 수 있는 대표적인 검정법은 두 독립된 이항분포의 비율에 대한 z-검정이다.\n\n사례: 현 정부에 대한 지지율이 성인 남녀별로 차이가 있는가?\n\n::: {#d319dc07 .cell execution_count=16}\n``` {.python .cell-code}\nimport pandas as pd\n\nurl = \"https://raw.githubusercontent.com/SHINJIHAN/advanced-bigdata/main/data/Support.csv\"\nSupport = pd.read_csv(url)\nSupport.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ID</th>\n      <th>Gender</th>\n      <th>YesNo</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>Male</td>\n      <td>No</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>Female</td>\n      <td>Yes</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>Female</td>\n      <td>No</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4</td>\n      <td>Female</td>\n      <td>No</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5</td>\n      <td>Female</td>\n      <td>No</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n이 데이터에 대한 2차원 분할표(빈도표) 작성하기.\n\n::: {#6ef3f977 .cell execution_count=17}\n``` {.python .cell-code}\nimport pandas as pd\nSupportTable = pd.crosstab(index = Support[\"Gender\"],\n                           columns = Support[\"YesNo\"])\n\nSupportTable\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>YesNo</th>\n      <th>No</th>\n      <th>Yes</th>\n    </tr>\n    <tr>\n      <th>Gender</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Female</th>\n      <td>96</td>\n      <td>104</td>\n    </tr>\n    <tr>\n      <th>Male</th>\n      <td>140</td>\n      <td>110</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n행 백분율 계산하기.\n\n::: {#bc0b0743 .cell execution_count=18}\n``` {.python .cell-code}\npd.crosstab(index=Support[\"Gender\"], columns=Support[\"YesNo\"],\n           normalize = \"index\") # 각 행의 합을 기준으로 비율을 계산\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>YesNo</th>\n      <th>No</th>\n      <th>Yes</th>\n    </tr>\n    <tr>\n      <th>Gender</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Female</th>\n      <td>0.48</td>\n      <td>0.52</td>\n    </tr>\n    <tr>\n      <th>Male</th>\n      <td>0.56</td>\n      <td>0.44</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n다음과 같은 교차 테이블(Cross Table)을 만들 수 있다.\n\n양측검증 적용.\n\n::: {#ebea22b9 .cell execution_count=19}\n``` {.python .cell-code}\nfrom scipy.stats import fisher_exact\nfisher_exact(SupportTable, \n             alternative = 'two-sided')\n             \n# 이 결과는 검정 통계량이 0.725이고 \n# p-값이 0.106(10.6%)이다.\n\n# 이는 일반적으로 사용되는 유의 수준 0.05(5%)에서 \n# 통계적으로 유의하지 않다는 것을 의미한다. \n\n# 결론적으로, 두 그룹(또는 변수) 간에 유의한 차이 또는 \n# 연관성을 찾지 못했다는 것을 나타낸다.\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\nSignificanceResult(statistic=np.float64(0.7252747252747253), pvalue=np.float64(0.10634531219761142))\n```\n:::\n:::\n\n\n정규 근사 검정\n\n이항분포의 표본 크기 n이 충분히 크면, 이항분포는 정규분포로 근사할 수 있으며, 이를 정규 근사라고 한다.\n일반적으로 n×p와 n×(1 − p)가 모두 5 이상이면, 정규분포로 근사할 수 있다고 간주한다.\n\n여기서  p 는 성공 확률이다.\n\n이러한 정규화된 변수를 제곱하면, 이는 카이제곱 분포를 따르게 된다.\n\n자유도가 1인 카이제곱 분포를 따른다.\n\n카이제곱검정(Chi-Square Test) 적용.\n\n::: {#44b280c1 .cell execution_count=20}\n``` {.python .cell-code}\nfrom scipy.stats import chi2_contingency\nchi2_contingency(SupportTable)\n\n# 카이제곱 통계량: 2.54\n# 유의 수준이 일반적으로 0.05(5%)인 경우, \n# p-값이 0.111(11.1%)이므로 귀무가설을 기각할 수 없다.\n\n# 따라서 이 결과는 두 변수 간에 통계적으로 \n# 유의한 연관성이 없다고 결론지을 수 있다. \n\n# 즉, 이 교차표에 따르면 두 변수는 독립적이다.\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\nChi2ContingencyResult(statistic=np.float64(2.5395141968952935), pvalue=np.float64(0.1110289428837834), dof=1, expected_freq=array([[104.88888889,  95.11111111],\n       [131.11111111, 118.88888889]]))\n```\n:::\n:::\n\n\n결론적으로, 현 정부에 대한 지지율이\n성인 남녀별로 차이가 없다고 할 수 있다.\n\n대응표본에 의한 두 모비율의 비교:\n\n맥니머 검정 \n\n맥니머 검정은 피셔의 정확검정이나 카이제곱 검정과 달리 대응 표본에 적용할 수 있는 검정이다.\n이 검정은 대응 표본 t-검정과 유사하게 교락 효과를 제거하는 것이 중요하다.\n\n독립 표본의 경우, 한 사람이 A, B 제품 모두를 사용하지 않아도 무방하다.\n그러나 대응 표본에서는 한 사람이 반드시 두 제품 모두를 사용해야 한다.\n\n사례: 정부에서 정책 발표 후 지지율에 변화가 있는가?\n\n::: {#15d7f918 .cell execution_count=21}\n``` {.python .cell-code}\nimport pandas as pd\n\nurl = \"https://raw.githubusercontent.com/SHINJIHAN/advanced-bigdata/main/data/Prepost.csv\"\nPrepost = pd.read_csv(url)\nPrepost.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ID</th>\n      <th>Pre</th>\n      <th>Post</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>Yes</td>\n      <td>Yes</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>No</td>\n      <td>No</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>Yes</td>\n      <td>No</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4</td>\n      <td>No</td>\n      <td>No</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5</td>\n      <td>No</td>\n      <td>No</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#b7565432 .cell execution_count=22}\n``` {.python .cell-code}\nimport pandas as pd\n\nPrepostTable = pd.crosstab(index = Prepost[\"Pre\"], \n                           columns = Prepost[\"Post\"], \n                           margins = True, # 각 행과 열의 합계 추가\n                           margins_name = \"합계\")\nPrepostTable\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Post</th>\n      <th>No</th>\n      <th>Yes</th>\n      <th>합계</th>\n    </tr>\n    <tr>\n      <th>Pre</th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>No</th>\n      <td>18</td>\n      <td>27</td>\n      <td>45</td>\n    </tr>\n    <tr>\n      <th>Yes</th>\n      <td>8</td>\n      <td>67</td>\n      <td>75</td>\n    </tr>\n    <tr>\n      <th>합계</th>\n      <td>26</td>\n      <td>94</td>\n      <td>120</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#afb21de2 .cell execution_count=23}\n``` {.python .cell-code}\npd.crosstab(index=Prepost[\"Pre\"], columns=Prepost[\"Post\"], \n            margins=True, margins_name=\"합계\", \n            normalize=\"all\") # 전체 데이터에 대한 비율 변환\n            \n# 정책 발표 이전 지지율(pre): 62.5%\n# 정책 발표 이후 지지율(post): 78.3%\n# 결과적으로 15.8%p가 상승하였음을 볼 수 있다.\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Post</th>\n      <th>No</th>\n      <th>Yes</th>\n      <th>합계</th>\n    </tr>\n    <tr>\n      <th>Pre</th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>No</th>\n      <td>0.150000</td>\n      <td>0.225000</td>\n      <td>0.375</td>\n    </tr>\n    <tr>\n      <th>Yes</th>\n      <td>0.066667</td>\n      <td>0.558333</td>\n      <td>0.625</td>\n    </tr>\n    <tr>\n      <th>합계</th>\n      <td>0.216667</td>\n      <td>0.783333</td>\n      <td>1.000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#3c523511 .cell execution_count=24}\n``` {.python .cell-code}\n# pip install statsmodels\n\nfrom statsmodels.stats.contingency_tables import mcnemar\nprint(mcnemar(PrepostTable, \n              exact = True)) # 이항분포 기반의 정확 검정 방법\n              \n# 0.001(0.1%) < 0.05(5%)\n\nprint(mcnemar(PrepostTable, \n              exact=False)) # 카이제곱분포를 사용한 근사 검정 방법\n              \n# 0.002(0.2%) < 0.05(5%)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npvalue      0.0018782254774123432\nstatistic   8.0\npvalue      0.0023457869795667934\nstatistic   9.257142857142858\n```\n:::\n:::\n\n\n결론적으로, 정부에서 정책 발표 전후 지지율에 변화가 있으며,\n정책 발표 후에 지지율이 상승한 것으로 볼 수 있다.\n\n모분산의 동일성에 대한 검정: \n\nF – 검정\n(F–test)\n\n가장 일반적인 검정 방법으로, 두 집단의 모분산이 동일한지 평가한다.\n두 집단의 분산 비율을 계산하고, 이를 기반으로 F–분포를 사용하여 p–값을 구한다.\n\nReading 데이터의 모분산이 다른가? \n\n\n이전에 다루었던 Reading 데이터에 대해\n분산의 동일성 검정을 위한 사용자 정의 함수를 작성하고, 가설검정을 수행하였다.\n\n::: {#cbf853df .cell execution_count=25}\n``` {.python .cell-code}\nimport pandas as pd\n\n# file_path = os.path.join('data', 'Reading.csv')\n# Reading = pd.read_csv(file_path)\n\nNew = Reading[Reading.Group == 'New']\nOld = Reading[Reading.Group == 'Old']\n\n\nimport numpy as np\nfrom scipy import stats\n\ndef F_test(x, y):\n    f = np.var(x, ddof = 1)/np.var(y, ddof = 1)\n    df1 = x.size -1 \n    df2 = y.size -1 \n    p = 2*(1-stats.f.cdf(f, df1, df2))\n    return f, p\n\nF_test(New.Score, Old.Score)\n\n# 0.8(80%) > 0.05(5%) \n# 귀무가설을 기각할 수 없다.\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n(1.1454545454545453, np.float64(0.8624138071371459))\n```\n:::\n:::\n\n\nBartlett's Test\n\n::: {#59df9798 .cell execution_count=26}\n``` {.python .cell-code}\nfrom scipy import stats\nstats.bartlett(New.Score, Old.Score)\n\n# 0.8(80%) > 0.05(5%) \n# 귀무가설을 기각할 수 없다.\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\nBartlettResult(statistic=np.float64(1.3291852026213666), pvalue=np.float64(0.24895022280539136))\n```\n:::\n:::\n\n\nLevene's Test\n\n::: {#972c941e .cell execution_count=27}\n``` {.python .cell-code}\nstats.levene(New.Score, Old.Score)\n\n# 0.6(60%) > 0.05(5%) \n# 귀무가설을 기각할 수 없다.\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\nLeveneResult(statistic=np.float64(0.1978798586572438), pvalue=np.float64(0.6632376240724351))\n```\n:::\n:::\n\n\n결론적으로, 두 집단의 모분산이 다르다고 말할 수 없다.\n\n---\n\n교제: 파이썬을 활용한 데이터 분석과 응용\n\n",
    "supporting": [
      "DAD6_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}