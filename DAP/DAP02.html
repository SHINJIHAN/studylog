<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>다변량 분석 – StudyLog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-7bb525a17dc475cd70bdc279c119312f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">StudyLog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">다변량 분석</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<blockquote class="blockquote">
<p>Reporting Date: November. 18, 2025</p>
</blockquote>
<p>[주제] 에 대해 다루고자 한다.</p>
<p>1 . 제목2 다중회귀 모델로 커퍼가 되었기 때문에 학부에서는 안 배웠다. 군집 분석은 텍스트데이터마이닝 k-민스와 같다고 할 수 있지만 그것은 아니다.</p>
<p>비지도 학습으로서 타겟이 없으며,</p>
<p>군집의 개수, 내용, 구조 등이 완전하게 알려지지 않는 상태에서 개체들 아이의 유사성 또는 거리에 근거하여 군집을 형성하고 형성된 군집의 특성을 파악해 군집들 간의 관계 분석</p>
<p>유클리드 거리, 맨해튼 거리, 코사인 유사도 등 측도를 달라도 거리로 본다는 점이 공통이다. 지표는 실루엣 계수, 엘보우 기법 등이 있다.</p>
<p>보통은 구형 모양이 가장 안정된 형태</p>
<ol type="1">
<li>군집이 긴 모양</li>
<li>개체 A,B 구 군집 사이의 고리 역할을 하는 경우</li>
</ol>
<p>금융(신용카드 고객 행동 패턴 분석)에선 세그멘테이션이 중요하다. 그외에 활용 분야 마케팅(고객 세분화), 헬스케어(환자 그룹 분류), 제조업(불량 패턴 탐지)</p>
<p>계층적 군집 분석, 또는 계보적 군집 분석 [최단, 최장, 형균, 중심, 중위수]연결법 Ward의 방법</p>
<p>과정</p>
<ol type="1">
<li><p>먼저 가장 가까운 2개의 개체를 묶어 하나의 군집을 만든다. 딱 하나만 나머지 개체는 각각이 하나의 군집을 이루도록 한다.</p></li>
<li><p>그리고 그 상태에서 가까운 것들을 조금씩 묶어 간다.</p></li>
<li><p>군집들 간 거리의 측도를 기준으로 각 단계마다 한 쌍씩 병합되어, 최종적으로 개체들을 모두 묶어 하나의 군집을 만드는 단계까지 방봅</p></li>
</ol>
<p>각 특징</p>
<p>최단 - 가장 가까운, 덴드로그램에서 긴 병합과정 최장 - 가장 먼 두 데이터, 덴드로그램에서 더 균형 잡힌 클러스터 구조 평균 - 두 데이터의 평균을 만들고 그걸 기반으로 거리 잼 중심 - 클러스터의 중심점을 계산, 중간 정도의 안정적인 군집 형성 중위수 - 거리를 중위값 기준 Ward의 방법 - 가장 많이 쓰임, 분산을 최소화하는 방식</p>
<p>scipy.cluster.hierarshy import l</p>
<p>protein.csv</p>
<p>최단 연결법(싱글)은 군집이 긴 모양에선 쓰지 않는 것이 좋음. 덴드로그램 시각화 함</p>
<p>데이터의 개수 및 빈도까지 고려된다. 단순 거리만 고려되지 않는다. 최단 연결법의 알고리즘, D_0에서 각 거리는 대칭이다. 매트릭스이고, 거리가 가장 짧은 것들을 본다. 예를 들어, 0과 1이 가장 짧으므로 하나의 군집이 된다. d1 d2의 거리는 1이다. 둘을 마지한다. 본래 4X4이였다면. 그러면 행렬이 3X3로 줄어든다. d1 d2는 c1이 된다. 또 다시 2X2로 된다. 이런 식으로 계산된다.</p>
<p>d(p1, p2) = 루트(x2 - x1)^2 + (y2 - y1)^2 계산식 해보기.</p>
<p>최장 연결법(컴플리트), 좀 더 분류를 크게 잘 함. 이것의 알고리즘도 최단과 시작은 비슷, 여기서 계산만 최장으로 한다. 각 알고리즘 기법의 결과 차이가 다르진 않음 그저 그룹잉하는 관점에 차이임.</p>
<p>평균 연결법(어버리지)이전보다 군집이 더 세분화됨. 자신만에 센터를 만든다는 다는 것이 차이</p>
<p>군집 분석은 주관적인 경향이 많음. 현업에서는 경험적을 우선으로 해야 됨. 자신이 배운 통계 솔루션을 너무 들이밀면 안됨. 그 이유는 데이터 결과는 감성적인 패턴이 안나오기 때문.</p>
<p>회사에서는 마스터 세그멘테이션을 지정한다. 고객을 대상으로 1년마다 갱신함.</p>
<p>신용은 가맹점 수수료 밖에 없음, 그러나 금융은 이자가 있음 그래서 금융이 더 많이 벌음. 그래서 각각의 세그멘테이션을 만들어야 되고, 개별로 비교해봐야 된다.</p>
<p>각 요소마다 단위가 다르다면, 표준화하여 진행한다.</p>
<p>중심 연결법도 이전과 마찬가지로 매트릭스를 만든다. X1과 X2가 있을 때 XX` = D(5*5)으로 계산해서 각 차원의 수가 들어든다. 군집의 분류를 어디부터 짤라야 하는가? 이것이 가장 중요하고 애매하다. 그래서 이를 도와주는 기법이 있다.</p>
<p>그래서 군집 분석은 통계학 분석 치고는 주관성이 약간 들어간 학문이다.</p>
<p>k-평균 군집분석</p>
<p>자주 사용하는 이유는 가장 효과적이고 대표적인 모델이기 때문에 그렇다.</p>
<p>최적분리 군집 방법의 절차</p>
<p>먼저 군집 초기값을 선택한다. 임의로 고르든 규칙적으로 고르든. 그 이후 초기 군집을 형성한다. 초기값들과의 거리를 계산된다. 이때 각 개체가 할당될 때마다 해당 군집의 중심이 그 군집에 속하는 걔체들의 평균 벡터로 다시 계산됨. 센터의 변동이 있음, 이제 별로 변동이 없어질 때까지 군집 중심들의 변화가 일정 수준 이하가 될 때까지 같은 과정을 반복한다. 시간은 많이 걸리나 가장 이상적인 군집분석이다. 각 군집과 구성원들을 묶는 그 방식을 조금씩 바꿔서 진행하는 것이다.</p>
<p>그럼 먼저 군집의 수를 잡는 방식으로 엘보우 기법을 사용한다. 엘보우의 경사도가 의미하는 것은 군집내에 제곱합이다. 굽집내 변이의 합계를 의미한다. 그 값이 작을수록 좋음을 나타내며 이는 동질이다. WSS가 급격히 감소하다가 완만하게 되는 지점이 적절한 군집의 개수에 대한 후보이다.</p>
<p>단위가 다를 수 있다. 데이터를 표준화시키고 다시 보는 방법도 가능하다. 다만, 유의할 것은 y축의 정보 손실이 발생할 가능성도 있다.</p>
<p>군집 3가지를 보고 싶으나 3차원이야. 그래서 차원을 축약해서 간단하게 보는 방법이 차원 축소이다. 그리고 각 클러스터가 라벨로 표시된다. 사실상 각 군집을 예측한 것이다. 이 포인트는 이 군집 안에 들어갈 것이다라고.</p>
<p>군집수 성능 지표(군집 결정 기중)</p>
<p>실루엣 계수는 개별 데이터가 할당된 군집 내에 데이터와 얼마나 가깝게 군집화 되어 있는지, 그리고 다른 군집에 있는 데이터와는 얼마나 멀리 있는지를 보는 것.</p>
<p>범위는 -1부터 1까지 마치 상관계수와 같다. 1에 가까울수록 좋은 것이다. 거리는 분산에 의해 결정된다.</p>
<p>붓꽃 데이터는 이미 다 조사를 했는데. 3종이 이미 되어 있다. 그러나 다시 분석을 하는 것은 이 기법으로 정말로 실효성이 있는가 에대한 가설 실험인 것이다.</p>
<p>엘보우 기법과 실루엣 계수간에 차이가 날 수 있다. 이것도 고민되는 이유이다. 갭 통계량, 약간 값을 벙튀기 하는 것. 관측된 군집간 변이와 균일 분포하에서의 군집간 변이의 기댓값을 비교하는 것으로 그 값이 클때 군집화가 잘 되었을 을 나타낸다.</p>
<p>부스트랩 반복횟수 지정(반복횟수를 크게 하면 시간이 많이 걸리지만 더 좋은 결과를 얻을 수 있다.)</p>
<p>값이 클수록 좋은 것이다. 그러나 만약 그보다 작은 값을 선택했다면? 과적합, 떄문에 그렇다. 이전에 엘보우과 실루엣 계수도 비교해서 결정해야 한다. 기울기도 보고 값의 크기를 더 많이 본다.</p>
<p>즉 보여지는 이론적 배경과 수치보다 현업의 이해도와 융통성이 있어야 된다. 유연하다는 것과 거짓정보를 주는 것은 다른다. 전문가의 의견을 많이 들어서 다 포함해야 한다. 애초에 사람들에게 쓰기 위해서 이론 수학보다 유연하게 만든 학문이기에.</p>
<p>분석사례 - NbClust (군집수를 결정하는 추가적인 통계량 제공) 왜 이 많은 걸 볼까? 그건 각 통계량마다 헛점들이 많기 때문이다. 만약에 2, 3가지로 봐서 명확하게 나오면 괜춘. 근데 애매하면 꼭 여러가지 기법을 총동원해서 최적의 군집을 찾고 그 성능과 신뢰도까지 보여줄 수 있어야 한다.</p>
<p>가우시안 매트릭스 모델(거리가 아닌 확률로 구한다)</p>
<p>베이지안 군집 분석: 여러개의 혼합된 모델일 경우에 좋다. 다변량 가우시안 모델이다.</p>
<p>베이지안 GMM은 클래스를 사용해서 구현. 군집 수에 대한 불확실성을 반영</p>
<p>검토하는 직관적인 방법 다른 통계적 방식에 비해 상대적으로 굉장히 복잡한 과정을 거친다.</p>
<p>특이값에 민감하다, 이유는 거리 기반이기 때문에 디스턴스 기반이기 떄문에 그렇다.</p>
<p>동일한 자료에 대해 다른 가정에 기초를 둔 여러 가지 군집 방법을 적용했을 때 대부분의 방법에서 제공된 결과가 유사한 결과가 나오는 가?</p>
<p>주어진 자료를 임의적으로 두 부분으로 나누고 각 부분을 독립적으로 군집시키는 방법 이때 군집들이 안정되어 있다면 그 결과는 유사</p>
<p>어떤 군집 분석 방법에 의하여 얻어지는 군집의 안정성을 알아보기 위해 몇 개의 일부 변수를 뺐다 꼈다해보기. 제거하여 군집의 구조에 어떤 영향을 미치게 될 것인가를 고찰하는 방법.</p>
<p>파셜 주성분 분석.(교수님 박사 논문)</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>