---
title: "분산분석: 이원분류 실습"
format: html
---

> Reporting Date: August. 5, 2024

이원분류 분산분석에 대해 다루고자 한다.

# 01 반복이 없는 이유

## 1. 반복이 없는 경우

반복을 하지 않는 것도 가능하다.
처치수준의 2개면 교오작용은 일어날 수 없다.
각각의 순수자기자신의 효과만을 볼 수 있다.
각각의 기각역이 생긴다.

예를 들면, 자동차이기 때문에 많이 반복하질 못했다.

일반적인 이원 분산 분석은 교오 작용 식이 존재한다.
그러나 임의화완전블록설계에선 교오 작용 식이 존재하지 않는다.

고객이 각각의 제품에 대해 어느 수준으로 평가할 것인가?
여기서, 어떤 제품 간의 관계가 같으냐 다르냐는 의미가 없음

각각 2개의 가설검증이 있어야 한다.

블록으로 처리해서 순수한 처치들에 대한 효과를 보겠다는 것
반복이 생길 땐 교오작용이 생김

import os
import pandas as pd

# 상대 경로 설정
file_path = os.path.join('data', 'Usage.csv')

# CSV 파일 읽기
Usage = pd.read_csv(file_path)

# 데이터 확인
Usage.head(5)

제품 혹은 소비자에 따라서 선호도의 차이가 있는가? 를 볼려고 하는 것이다.
소비자도 처치로 놓을 수 있다. 실무에서는 소비자의 개인보다는 그룹일 가능성이 더 높으며 그게 더 맞다.
그리고 고객을 대상으로도 반복이 없는 분석 진행이 생각보다 많다.



총변동은 변함이 없는데 이를 계산은 SSA, SSB, SSE로 나뉜다
시그마a 시그마b ( yij  - y헷.. )^2 =  시그마a 시그마b (yij - y헷i. + y헷i. + y헷.j - y헷.j + y헷..)^2 를 기준으로 식이 출발한다.
이 식은 2가지로 묶에서 더한 식으로 진행하고 지워지는 것을 지우면 y헷.. 만이 남을 것이다.
이것은 각 A, B의 평균의 차이를 보이는 총변동을 보려하려는 것.

평균제곱합은 3가지, F값은 2가지가 나와야 한다.
반복이 없을 때에는 교오작용이 들어가지 않는다. 왜?

from bioinfokit.analys import stat
res = stat()
res.anova_stat(df = Usage, res_var = 'Prefer',
              anova_model = 'Prefer~C(Customer)+Product', ss_typ=3)
res.anova_summary

소비자에 대한 효과는 없고, 제품에 대한 효과만 있다.



C = 5 - 1
R = 전체 샘플 사이즈 - 모든 자유도 = 20 - 6 = 12
3 나누기 126 = 38

수준에 따라 차이가 있다면 어느 제품의 수준이 가장 좋은가?

따라서 기초통계량으로 어느 곳에 차이가 나는지를 보았다.

Usage.groupby("Product").agg({"Prefer":["mean", "std", "min", "max"]})

선호 점수의 차이가 있다. A1을 가장 선호한다. 
여기서 끝내지 않고, 어디에서 차이가 나는지를 확인하기 위해 다중비교를 한다.

```{}
res.tukey_hsd(df=Usage, res_var = 'Prefer', xfac_var='Product',
             anova_model='Prefer~C(Customer)+Product')
res.tukey_summary
```
0번과 2번은 차이가 있다. 나머지 차이가 없다는 건 사실상 같은 그룹으로 묶어도 된다는 의미이다.

```{}
from statsmodels.stats.multicomp import pairwise_tukeyhsd

res = stat()
df = pd.DataFrame(Usage)
res.tukey_summary = pairwise_tukeyhsd(endog = df['Prefer'], 
                                      groups = df['Product'], alpha = 0.05)
print(res.tukey_summary)
```

여기까지가 반복이 없는 경우이다.

# 01 반복이 있는 경우
2p 실험설계

## 2. 반복이 있는 경우
y11r: 1번만 한 것이 아니라 r번씩 반복한 것.
분산분석표에서 상호작용(SSAB)가 존재한다.
3개의 요인을 분석만 해도, 모델은 기하급수적으로 복잡해진다.

그러나 사실 변수의 개수가 3라고 해도 별로 특별한 이유가 아니다.
그러니 다른 분석 기법에 비해 해석 방법이 매우 복잡한 것이 그 이유이다.

여기선 교오작용에 대한 효과도 고려한다. 식에도 포함된다.
F통계량도, 귀무가설도 3개로 늘어난다.

A, B, C 디자인에 대한 대, 중, 소 도시
지역에 따라 어떤 디자인이 먹힐 것인가?

판매한 결과를 표로 작성하였다.
데이터를 먼저 설계하는 것이 가장 중요하다.


import os
import pandas as pd

# 상대 경로 설정
file_path = os.path.join('data', 'Market.csv')

# CSV 파일 읽기
Market = pd.read_csv(file_path)

# 데이터 확인
Market.head(5)

12개의 관측치, 디자인과 도시, 판매량
여기서 반복인지 아닌지 알수 있어야 한다.

기초 통계량

Market.groupby("City").agg({"Sales":["mean", "std", "min", "max"]})

도시에서는 차이가 나는 지 잘 모르겠다.

기초 통계량

Market.groupby("Design").agg({"Sales":["mean", "std", "min", "max"]})



교오작용 확인하기.

Market.groupby(["City", "Design"]).agg({"Sales":["mean", "std", "min", "max"]})

순수하게 보았을 때에는 차이가 보이지 않았으나, 둘이서 같이 보니
소도시에서 A와 C에서 차이가 나는 것을 확인할 수 있다. 교오작용을 존재할 수도 있겠다고 
차이가 난다고 추측할 수 있다. 이런 식으로 근거를 찾는 탐색적 분석이 필요하다.

모든 분석은 전체적인 스케치를 한 다음에 모델을 적용하는 것이다.
아래는 개별 도시와 그것에 합친 교오작용 그래프

Market.boxplot("Sales", by = "City")
Market.boxplot("Sales", by = "Design")
Market.boxplot("Sales", by = ["City", "Design"])





중위수가 박스의 윗쪽에 있으므로, 




B디자인을 더 선호한다.






시티를 먼저 썼으므로, 대중소가 차례로 나온다.
가장 많은 것은 중도시의 B이다.

대도시와 소도시는 서로 다른 패턴을 보인다.





import matplotlib.pyplot as plt
import seaborn as sns
sns.pointplot(x="City", y="Sales", color='red', data = Market)
sns.pointplot(x="Design", y="Sales", color='green', data = Market)

B가 가장 높은 것을 알 수 있다.





분산분석 실시

from bioinfokit.analys import stats
res = stat()
res.anova_stat(df = Market, res_var = 'Sales',
			  # City:Design: 교오작용
              anova_model = 'Sales ~ City + Design + City:Design', ss_typ = 3)
res.anova_summary

교오작용은 콜론(:)으로 쓴다.
여기도 책에 문제가 있음, 확실한 차이가 존재함을 알 수 있음
디자인에 차이가 있고, 디자인과 도시간 교오작용에서도 차이가 있다.

sns.pointplot(x="City", y="Sales", hue = "Design", ci = 0, data = Market,
             markers = ["o", "*", "s"], linestyles = ["-", "--", ":"])

겹치는 부분이 존재하므로, 교오작용이 존재한다.
여러가지 일은 하는 것보다 한가지만을 특화해서 하는 것도 방법이다.;
그렇지 않고 모두 떨어지거나 모두 올라가면 교오 작용이 없는 것이다.

# 01 3원 분류
잔차를 포함해서 2의 3승 개의 
이 분산분석표의 교오작용이 있다면 이것으로도 만족되지만
tukey는 더 명확하게 보고 싶으면 하는 방법이다. 꼭 사용해야만 하는 방법은 아니고 추가 지표이다.
이런 건 스마트 팩토리, 바이오 분야에서 더 많이 쓰이고, 실제 실무에선 많이 쓰이진 않을 수 있다.
그리고 여기서도 변수의 수가 많다고 무조건 과적합이 발생된다고 단정하면 안된다.
실무에선 20-30개 변수를 사용하는 건 기본이지만서도 분산분석에서는 그렇게 많이도 하진 않는다.
비용대비 결과가 만족스럽게 나오진 않기에. 그래도 적어도 변수는 3-5개까지는 한다는 것이다.
그리고 교오 작용에서도 몇 번째의 각각 ABC이냐까지 고려 해야 한다.

반복이 없는 경우

반복이 있는 경우

공분산 분석

처리요인이 아니면서 반응변수에 영향을 주는 요인을 교락요인이란 한다.
교략요인은 범주형(그룹형, 블록) 형태와 연속형(공변량)인 경우가 있음
이럴 경우, 적용하는 것이 공분산 분석이다.

이 공변량을 모형에 추가적인 설명변수로 삽입하여
그 효과를 제거했다면 그런 영향을 주는 공변량 변동을 미리 제거하여 
순수한 처리효과를 파악하고자 하는 통계적 기법 실험 정도를 높이고, 실험의 편의를 높이기 위해 사용한다.

참고로 범주형일 땐 공분산 분석을 할 수 없음.

예제: 심리 점수 데이터 20명의 사람을 10명 씩 두 개의 집단으로 나눈 다음, 
기존 방법과 신규 방법으로 공부를 한 다음 심리 점수를 측정하였다.

사람의 나이 데이터는 연속형 데이터이다. 그러나 이것은 처치요인은 아니므로,
이러한 것을 교략요인이자 공변량이라고 부르는 것이며 이때, 공분산 분석을 하는 것이다.

그래서 먼저 아무것도 하지 않는 비교 집단을 기존방법1 실험 집단을 신규방법2으로 한다.
이것을 아노바로 하는 것은 과하다. t 검정 (분산 분석)을 먼저 한다. 그래서 식을 세운다. 
집단 1, 2의 평균을 구한 뒤 각 평균의 차이를 계산한다.

이번엔 공분산 분석을 한다. 이때 여기선 베타x1j라는 나이 변수를 넣었다.

import os
import pandas as pd

# 상대 경로 설정
file_path = os.path.join('data', 'Ancova.csv')

# CSV 파일 읽기
Ancova = pd.read_csv(file_path)

# 데이터 확인
Ancova.head(5)





import statsmodels.api as sm
import statsmodels.formula.api as smf
AncovaFit = smf.ols(formula = 'Score~Age+C(Group)', data = Ancova).fit()
AncovaFit.summary()

이를 통해 공분산 분석을 진행하였다.

변수를 한꺼번에 넣는 게 아니라 타입1은 순서대로 넣어서 테이블을 만듦
원way에서는 상관없고 투way부터 상호작용이 생기는 데 이를 존재하지 않다고 말하는 게 타입 2이다.
메인 효과만 고려. 상호작용까지 고려하는 게 타입3 이다. 그래서 타입3를 대부분 사용하는 것이다.

언발라스드 디자인, 이란 셀의 크기가 다를 경우, 를 의미한다.
일부 셀에 데이터가 없는 경우에 타입에 따라서 결과값이 달라진다. 그럴땐 타입3를 사용하는 것이 적절하다.
또한 유닉크 효과 테스팅, 순수한 자기 효과만을 보여준다는 것이다.





sm.stats.anova_lm(AncovaFit, typ = 3)





Ancova.groupby("Group").agg({"Score":["mean", "std", "min", "max"]})





Control = Ancova[Ancova['Group'] == 1]
Treatment = Ancova[Ancova['Group'] == 2]

from statsmodels.stats.weightstats import ttest_ind
ttest_ind(Control['Score'], Treatment['Score'], alternative='smaller', 
          usevar='pooled')





import statsmodels.formula.api as smf
AncovaFit1 = smf.ols(formula = 'Score~Age+C(Group)+Age:C(Group)',
                    data = Ancova).fit()
AncovaFit.summary()

---

교제: 파이썬을 활용한 데이터 분석과 응용